import * as mersenneTwister from './node_modules/mersenne-twister';


let results: Position[];
let running: Boolean;
let finished: Boolean;






class Application {
    private numberOfCats: number;
    private mixtureRatio: number;
    private selfPositionConsidering: Boolean;
    private seekingRangeOfSelectedDimension: number;
    private countsOfDimensionsToChange: number;
    private seekingMemoryPool: number;
    private constantNumber: number;
    private searchDomain:Position;

    private seekingMode: ISeekingMode;
    private tracingMode: ITracingMode;
    private cats: Cat[];
    private fitnessValueBest: number;
    private fitnessValueLeast: number;
    private bestPosition: Position;

    private maximumNumberOfIterations = 500;
    private iterationcounter = 0;
    private results: Position[];

    constructor(numberOfCats: number, 
                mixtureRatio: number, 
                selfPositionConsidering: Boolean,
                seekingRangeOfSelectedDimension: number,
                countsOfDimensionsToChange: number,
                seekingMemoryPool: number,
                constantNumber: number,
                searchDomain: Position) {
                    this.numberOfCats = numberOfCats;
                    this.mixtureRatio = mixtureRatio;
                    this.selfPositionConsidering = selfPositionConsidering;
                    this.seekingRangeOfSelectedDimension = seekingRangeOfSelectedDimension;
                    this.countsOfDimensionsToChange = countsOfDimensionsToChange;
                    this.seekingMemoryPool = seekingMemoryPool;
                    this.constantNumber = constantNumber;
                    this.searchDomain = searchDomain;
                    this.seekingMode = new ClassicalSeekingMode(this.seekingMemoryPool, this.seekingRangeOfSelectedDimension, this.countsOfDimensionsToChange, this.selfPositionConsidering);
                    this.tracingMode = new ClassicalTracingMode(this.constantNumber, this.searchDomain);
                    this.cats = new Cat[this.numberOfCats];
                    this.results = new Position[this.maximumNumberOfIterations];
                    this.createCats();
    }

    private createCats() {
        for(let i = 0; i < this.numberOfCats; i++) {
            const velocity = new Position(0,0);
            const position = new Position(0,0);
            this.cats[i] = new Cat(position.doRandomPosition(), velocity.doRandomPosition());
        }
    }

    private giveCatsModi() {
        for(let i = 0; i < this.numberOfCats; i++) {
            const randomNumber = mersenneTwister.random();
            if(randomNumber <= this.mixtureRatio) {
                this.cats[i].setMode(false);
            } else {
                this.cats[i].setMode(true);
            }
        }
    }

    private checkForBestFitnessValue() {
        this.fitnessValueBest = 10000;
        for(let i = 0; i < this.numberOfCats; i++) {
            if(this.cats[i].calculateFitness() < this.fitnessValueBest) {
                this.fitnessValueBest = this.cats[i].calculateFitness();
                this.bestPosition = this.cats[i].getPosition();
            }
        }
    }

    private checkForLeastFitnessValue() {
        this.fitnessValueBest = -10000;
        for(let i = 0; i < this.numberOfCats; i++) {
            if(this.cats[i].calculateFitness() > this.fitnessValueBest) {
                this.fitnessValueLeast = this.cats[i].calculateFitness();
            }
        }
    }

    optimize() {
        while(this.iterationcounter < this.maximumNumberOfIterations) {
            this.checkForBestFitnessValue();
            this.checkForLeastFitnessValue();
            this.giveCatsModi();
            this.results[this.iterationcounter] = this.bestPosition;

            for(let i = 0; i < this.numberOfCats; i++) {
                if(this.cats[i].getMode()) {
                    this.seekingMode.seek(this.cats[i], this.fitnessValueBest, this.fitnessValueLeast);
                } else {
                    this.tracingMode.trace(this.cats[i], this.bestPosition);
                }
            }
            this.iterationcounter++;
        }
    }
}

function startWorker(functionToOptimize, 
                     searchDomain, 
                     constantNumber, 
                     numberOfCats, 
                     mixtureRatio, 
                     seekingMemoryPool, 
                     seekingRangeOfSelectedDimension, 
                     countsOfDimensionsToChange, 
                     selfPositionConsidering) {

    const application = new Application(numberOfCats, 
                                        mixtureRatio, 
                                        selfPositionConsidering, 
                                        seekingRangeOfSelectedDimension, 
                                        countsOfDimensionsToChange, 
                                        seekingMemoryPool, 
                                        constantNumber, 
                                        searchDomain);
    
    application.optimize();

    finished = running;
    running = false;
};

addEventListener('message', function (message) {
    try {
        if (message.data.messageType == "start") {
            running = true;
            finished = false;
            startWorker(message.data.functionToOptimize,
                        message.data.searchDomain, 
                        message.data.constantNumber,
                        message.data.numberOfCats, 
                        message.data.mixtureRatio,
                        message.data.seekingMemoryPool, 
                        message.data.seekingRangeOfSelectedDimension,
                        message.data.countsOfDimensionsToChange,
                        message.data.selfPositionConsidering);
  //          postMessage({
  //              messageType: "return",
   //             finished: finished,
   //             msaImgData: message.data.msaImgData,
  //              startX: message.data.startX,
  //              startY: message.data.startY,
  //              index: message.data.index
  //          });
            return;
        }
        if (message.data.messageType == "stop") {
            running = false;
            finished = false;
            return;
        }
    } catch (e) {
  //      postMessage({
  //          messageType: "error",
  //          messageError: e.name + " " + e.message + " " + e.stack
   //     });

    }
    this.close();
});